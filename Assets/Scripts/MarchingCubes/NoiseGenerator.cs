using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UIElements;

public class NoiseGenerator : MonoBehaviour
{
    /// <summary>
    /// this buffer is responsible for communicating the noise values
    /// generated by the GPU compute shader back to the CPU C# script.
    /// </summary>
    private ComputeBuffer _weightsBuffer;
    
    public ComputeShader noiseShader;
    
    [SerializeField] private float amplitude = 10;
    [SerializeField] private float frequency = 0.002f;
    [SerializeField] private int octaves = 8;
    [SerializeField] private int hardFloor = 2;
    [SerializeField] private int terraceHeight = 6;
    [SerializeField, Range(0f, 1f)] private float groundPercent = 0.2f;

    #region Shader properties

    private static readonly int Weights = Shader.PropertyToID("weights");
    private static readonly int ChunkSize = Shader.PropertyToID("chunk_size");
    private static readonly int Amplitude = Shader.PropertyToID("amplitude");
    private static readonly int Frequency = Shader.PropertyToID("frequency");
    private static readonly int Octaves = Shader.PropertyToID("octaves");
    private static readonly int GroundPercent = Shader.PropertyToID("ground_percent");
    private static readonly int HardFloor = Shader.PropertyToID("hard_floor_y");
    private static readonly int TerraceHeight = Shader.PropertyToID("terrace_height");
    private static readonly int Scale = Shader.PropertyToID("scale");
    private static readonly int GroundLevel = Shader.PropertyToID("ground_level");

    #endregion
    
    public float[] GetNoise(int lod)
    {
        CreateBuffers(lod);
        // Array of floats with size equal to the size of the 3d grid
        float[] noiseValues = 
            new float[GridMetrics.PointsPerChunk(lod) * GridMetrics.PointsPerChunk(lod) * GridMetrics.PointsPerChunk(lod)];
        
        // Communicate between GPU and CPU (compute shader to C# script)
        noiseShader.SetBuffer(0, Weights, _weightsBuffer);

        noiseShader.SetInt(Scale, GridMetrics.Scale);
        noiseShader.SetInt(ChunkSize, GridMetrics.PointsPerChunk(lod));
        noiseShader.SetFloat(Amplitude, amplitude);
        noiseShader.SetFloat(Frequency, frequency);
        noiseShader.SetInt(Octaves, octaves);
        noiseShader.SetFloat(GroundPercent, groundPercent);
        noiseShader.SetInt(HardFloor, hardFloor);
        noiseShader.SetInt(TerraceHeight, terraceHeight);
        noiseShader.SetInt(GroundLevel, GridMetrics.GroundLevel);
        
        // Dispatch shader, with one kernel (index 0), and (GridMetrics.PointsPerChunk/GridMetrics.NumThreads)
        // workgroups for each dimension to create 3d a grid
        noiseShader.Dispatch(
            0, 
            GridMetrics.ThreadGroups(lod), 
            GridMetrics.ThreadGroups(lod), 
            GridMetrics.ThreadGroups(lod)
        );
        
        // Transfer the data on the buffer back to the noiseValues array.
        _weightsBuffer.GetData(noiseValues);
        
        ReleaseBuffers();
        return noiseValues;
    }

    void CreateBuffers(int lod) {
        _weightsBuffer = new ComputeBuffer(
            GridMetrics.PointsPerChunk(lod) * GridMetrics.PointsPerChunk(lod) * GridMetrics.PointsPerChunk(lod), 
            sizeof(float)
        );
    }

    void ReleaseBuffers() {
        _weightsBuffer.Release();
    }
}
